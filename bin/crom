#!/usr/bin/env node

var fs = require("fs"),
    path = require("path"),
    crypto = require("crypto"),
    rimraf = require("rimraf"),
    unzip = require("unzip"),
    queue = require("d3-queue");

var Registry = require("../lib/Registry"),
    Root = require("../lib/Root");

require("../plugin/GitHub");

if (process.argv[2] !== "install") {
  console.error("error: unknown command " + process.argv[2]);
  return process.exit(1);
}

if (!process.argv[3]) {
  console.error("error: missing install target");
  return process.exit(1);
}

function ExternalError(message) {
  this.message = message;
}

ExternalError.prototype = Object.create(new Error);

Root.init(".", function(error, root) {
  if (error) throw error;

  var q = queue(1);
  for (var i = 3, n = process.argv.length; i < n; ++i) {
    var name = process.argv[i], j = name.indexOf("@"), range = "*";
    if (j >= 0) range = name.slice(j + 1), name = name.slice(0, j);
    q.defer(findAndInstall, root, name, range);
  }
  q.awaitAll(done);

  function done(error) {
    if (error instanceof ExternalError) {
      console.error("error: " + error.message);
      return process.exit(1);
    }
    if (error) throw error;
  }
});

function findAndInstall(root, name, range, callback) {
  Registry.findModules(name, function(error, modules) {
    if (error) return void callback(error);
    if (!modules.length) return void callback(new ExternalError("module “" + name + "” not found"));

    for (var i = 0, n = modules.length; i < n; ++i) {
      console.log((i ? "✗" : "✓") + " " + modules[i]);
    }

    findAndInstallRelease(root, modules[0], range, function(error, release, hash) {
      if (error) return void callback(error);

      root.install(release, hash, range, function(error) {
        if (error) return void callback(error);
        console.log("✓ " + path.join(root.dir, "crom.json"));
        callback(null);
      });
    });
  });
}

function findAndInstallRelease(root, module, range, callback) {
  module.findRelease(range, function(error, release) {
    if (error) return void callback(error);
    if (!release) return void callback(new ExternalError("release " + module.url + "@" + range + " not found"));
    console.log("✓ " + release);

    var file = path.join(root.dir, "crom_modules", crypto.createHash("sha256")
        .update(release.url)
        .digest("hex") + ".zip");

    release.download(fs.createWriteStream(file), function(error) {
      if (error) return void callback(error);
      console.log("✓ " + file);
      extractRelease(root, release, file, callback);
    });
  });
}

function computeHash(file, callback) {
  var hash = crypto.createHash("sha256");
  fs.createReadStream(file)
      .on("data", function(chunk) { hash.update(chunk); })
      .on("error", callback)
      .on("end", function() { callback(null, hash.digest("hex")); });
}

function extractRelease(root, release, file, callback) {
  computeHash(file, function(error, hash) {
    if (error) return void callback(error);
    var dir = path.join(root.dir, "crom_modules", hash);

    rimraf(dir, function(error) {
      if (error) return void callback(error);

      fs.createReadStream(file)
          .pipe(unzip.Extract({path: dir}))
          .on("error", callback)
          .on("close", function() {
            console.log("✓ " + dir);
            callback(null, release, hash);
          });
    });
  });
}
